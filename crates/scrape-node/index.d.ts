/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * A pre-compiled CSS selector for efficient repeated matching.
 *
 * Compiled selectors avoid the overhead of parsing the selector string on each query.
 *
 * @example
 * ```javascript
 * import { CompiledSelector, Soup } from 'scrape-rs';
 *
 * const selector = CompiledSelector.compile("div.item");
 * const soup = new Soup("<div class='item'>A</div><div class='item'>B</div>");
 * const items = soup.selectCompiled(selector);
 * console.log(items.length); // 2
 * ```
 */
export declare class CompiledSelector {
  /**
   * Compile a CSS selector string.
   *
   * @param selector - The CSS selector to compile
   * @returns A compiled selector
   * @throws Error if the selector syntax is invalid
   */
  static compile(selector: string): CompiledSelector
  /**
   * Get the original selector string.
   *
   * @returns The selector string that was compiled
   */
  get source(): string
}

/**
 * A parsed HTML document.
 *
 * @example
 * ```javascript
 * import { Soup } from 'scrape-rs';
 *
 * const soup = new Soup("<div>Hello</div>");
 * const div = soup.find("div");
 * console.log(div.text); // "Hello"
 * ```
 */
export declare class Soup {
  /**
   * Parse an HTML string into a Soup document.
   *
   * @param html - HTML string to parse
   * @param config - Optional parsing configuration
   */
  constructor(html: string, config?: SoupConfig | undefined | null)
  /**
   * Parse HTML from a file.
   *
   * @param path - Path to the HTML file
   * @param config - Optional parsing configuration
   * @returns A new Soup instance
   * @throws Error if the file cannot be read
   */
  static fromFile(path: string, config?: SoupConfig | undefined | null): Soup
  /**
   * Find the first element matching a CSS selector.
   *
   * @param selector - CSS selector string
   * @returns The first matching Tag, or null if not found
   * @throws Error if the selector syntax is invalid
   */
  find(selector: string): Tag | null
  /**
   * Find all elements matching a CSS selector.
   *
   * @param selector - CSS selector string
   * @returns Array of matching Tag instances
   * @throws Error if the selector syntax is invalid
   */
  findAll(selector: string): Array<Tag>
  /**
   * Find all elements matching a CSS selector (alias for findAll).
   *
   * @param selector - CSS selector string
   * @returns Array of matching Tag instances
   */
  select(selector: string): Array<Tag>
  /**
   * Get the root element of the document.
   *
   * @returns The root Tag (usually <html>), or null for empty documents
   */
  get root(): Tag | null
  /**
   * Get the document title.
   *
   * @returns The title text, or null if no <title> element exists
   */
  get title(): string | null
  /**
   * Get the text content of the entire document.
   *
   * @returns All text content with HTML tags stripped
   */
  get text(): string
  /**
   * Get the HTML representation of the document.
   *
   * @returns The document as an HTML string
   */
  toHtml(): string
  /** Get the number of nodes in the document. */
  get length(): number
  /**
   * Find the first element matching a compiled selector.
   *
   * @param selector - A compiled CSS selector
   * @returns The first matching Tag, or null if not found
   */
  findCompiled(selector: CompiledSelector): Tag | null
  /**
   * Find all elements matching a compiled selector.
   *
   * @param selector - A compiled CSS selector
   * @returns Array of matching Tag instances
   */
  selectCompiled(selector: CompiledSelector): Array<Tag>
  /**
   * Parse an HTML fragment without html/body wrapper.
   *
   * @param html - HTML fragment string to parse
   * @param context - Optional context element name (default: "body")
   * @param config - Optional parsing configuration
   * @returns A new Soup instance containing the fragment
   *
   * @example
   * ```javascript
   * import { Soup } from 'scrape-rs';
   *
   * // Parse without wrapper
   * const soup = Soup.parseFragment("<div>A</div><div>B</div>");
   * const divs = soup.findAll("div");
   * console.log(divs.length); // 2
   *
   * // Parse with td context
   * const tdSoup = Soup.parseFragment("<td>Cell</td>", "tr");
   * ```
   */
  static parseFragment(html: string, context?: string | undefined | null, config?: SoupConfig | undefined | null): Soup
  /**
   * Extract text content from all elements matching a selector.
   *
   * @param selector - CSS selector string
   * @returns Array of text content strings
   * @throws Error if the selector syntax is invalid
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div>A</div><div>B</div>");
   * const texts = soup.selectText("div");
   * // texts: ["A", "B"]
   * ```
   */
  selectText(selector: string): Array<string>
  /**
   * Extract attribute values from all elements matching a selector.
   *
   * @param selector - CSS selector string
   * @param attr - Attribute name to extract
   * @returns Array of attribute values (null if attribute is missing)
   * @throws Error if the selector syntax is invalid
   *
   * @example
   * ```javascript
   * const soup = new Soup("<a href='/a'>A</a><a href='/b'>B</a><a>C</a>");
   * const hrefs = soup.selectAttr("a", "href");
   * // hrefs: ["/a", "/b", null]
   * ```
   */
  selectAttr(selector: string, attr: string): Array<string | undefined | null>
}

/**
 * An HTML element in the document.
 *
 * Provides access to element content, attributes, and tree navigation.
 *
 * @example
 * ```javascript
 * const soup = new Soup('<div class="test">Hello</div>');
 * const div = soup.find("div");
 * console.log(div.name);         // "div"
 * console.log(div.text);         // "Hello"
 * console.log(div.attr("class")); // "test"
 * ```
 */
export declare class Tag {
  /** Get the tag name (e.g., "div", "span"). */
  get name(): string | null
  /** Get the text content of this element and all descendants. */
  get text(): string
  /** Get the inner HTML content (excluding this element's tags). */
  get innerHTML(): string
  /** Get the outer HTML (including this element's tags). */
  get outerHTML(): string
  /**
   * Get an attribute value by name.
   *
   * @param name - The attribute name
   * @returns The attribute value, or null if not present
   */
  attr(name: string): string | null
  /**
   * Get an attribute value by name (alias for attr).
   *
   * @param name - The attribute name
   * @returns The attribute value, or null if not present
   */
  get(name: string): string | null
  /**
   * Check if the element has an attribute.
   *
   * @param name - The attribute name
   * @returns True if the attribute exists
   */
  hasAttr(name: string): boolean
  /** Get all attributes as an object. */
  get attrs(): Record<string, string>
  /**
   * Check if the element has a specific class.
   *
   * @param className - The class name to check
   * @returns True if the element has the class
   */
  hasClass(className: string): boolean
  /** Get all classes as an array. */
  get classes(): Array<string>
  /** Get the parent element. */
  get parent(): Tag | null
  /** Get all direct child elements. */
  get children(): Array<Tag>
  /** Get the next sibling element. */
  get nextSibling(): Tag | null
  /** Get the previous sibling element. */
  get prevSibling(): Tag | null
  /** Get all descendant elements. */
  get descendants(): Array<Tag>
  /** Get all ancestor elements (from parent toward root). */
  get parents(): Array<Tag>
  /** Get all ancestor elements (alias for parents). */
  get ancestors(): Array<Tag>
  /**
   * Find the nearest ancestor matching a CSS selector.
   *
   * @param selector - CSS selector string
   * @returns The nearest matching ancestor Tag, or null if not found
   * @throws Error if the selector syntax is invalid
   */
  closest(selector: string): Tag | null
  /** Get all following sibling elements. */
  get nextSiblings(): Array<Tag>
  /** Get all preceding sibling elements (in reverse order). */
  get prevSiblings(): Array<Tag>
  /** Get all sibling elements (excluding self, in document order). */
  get siblings(): Array<Tag>
  /**
   * Find the first descendant matching a CSS selector.
   *
   * @param selector - CSS selector string
   * @returns The first matching Tag, or null if not found
   * @throws Error if the selector syntax is invalid
   */
  find(selector: string): Tag | null
  /**
   * Find all descendants matching a CSS selector.
   *
   * @param selector - CSS selector string
   * @returns Array of matching Tag instances
   * @throws Error if the selector syntax is invalid
   */
  findAll(selector: string): Array<Tag>
  /** Find all descendants matching a CSS selector (alias for findAll). */
  select(selector: string): Array<Tag>
  /** Get the number of direct child elements. */
  get length(): number
  /**
   * Find the first descendant matching a compiled selector.
   *
   * @param selector - A compiled CSS selector
   * @returns The first matching Tag, or null if not found
   */
  findCompiled(selector: CompiledSelector): Tag | null
  /**
   * Find all descendants matching a compiled selector.
   *
   * @param selector - A compiled CSS selector
   * @returns Array of matching Tag instances
   */
  selectCompiled(selector: CompiledSelector): Array<Tag>
  /**
   * Get all direct text nodes (excluding descendants).
   *
   * @returns Array of text content strings
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div>Text1<span>Inner</span>Text2</div>");
   * const div = soup.find("div");
   * const texts = div.textNodes;
   * // texts: ["Text1", "Text2"]
   * ```
   */
  get textNodes(): Array<string>
  /**
   * Get all direct child elements with a specific tag name.
   *
   * @param name - The tag name to filter by
   * @returns Array of matching child Tag instances
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div><p>A</p><span>B</span><p>C</p></div>");
   * const div = soup.find("div");
   * const paras = div.childrenByName("p");
   * // paras.length: 2
   * ```
   */
  childrenByName(name: string): Array<Tag>
  /**
   * Get all direct child elements with a specific class.
   *
   * @param className - The class name to filter by
   * @returns Array of matching child Tag instances
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div><p class='item'>A</p><span>B</span><p class='item'>C</p></div>");
   * const div = soup.find("div");
   * const items = div.childrenByClass("item");
   * // items.length: 2
   * ```
   */
  childrenByClass(className: string): Array<Tag>
  /**
   * Extract text content from all descendants matching a selector.
   *
   * @param selector - CSS selector string
   * @returns Array of text content strings
   * @throws Error if the selector syntax is invalid
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div><p>A</p><p>B</p></div>");
   * const div = soup.find("div");
   * const texts = div.selectText("p");
   * // texts: ["A", "B"]
   * ```
   */
  selectText(selector: string): Array<string>
  /**
   * Extract attribute values from all descendants matching a selector.
   *
   * @param selector - CSS selector string
   * @param attr - Attribute name to extract
   * @returns Array of attribute values (null if attribute is missing)
   * @throws Error if the selector syntax is invalid
   *
   * @example
   * ```javascript
   * const soup = new Soup("<div><a href='/a'>A</a><a href='/b'>B</a></div>");
   * const div = soup.find("div");
   * const hrefs = div.selectAttr("a", "href");
   * // hrefs: ["/a", "/b"]
   * ```
   */
  selectAttr(selector: string, attr: string): Array<string | undefined | null>
}

/**
 * Parse multiple HTML documents in parallel.
 *
 * Uses Rayon for parallel processing. Provides significant speedup
 * when parsing many documents.
 *
 * @param documents - Array of HTML strings to parse
 * @param config - Optional parsing configuration
 * @returns Array of Soup instances in the same order as input
 *
 * @example
 * ```javascript
 * import { parseBatch } from 'scrape-rs';
 *
 * const htmls = ['<div>A</div>', '<div>B</div>', '<div>C</div>'];
 * const soups = parseBatch(htmls);
 * const texts = soups.map(s => s.find('div').text);
 * // texts: ['A', 'B', 'C']
 * ```
 */
export declare function parseBatch(documents: Array<string>, config?: SoupConfig | undefined | null): Array<Soup>

/**
 * Configuration options for HTML parsing.
 *
 * @example
 * ```javascript
 * const config = {
 *   maxDepth: 256,
 *   strictMode: false,
 *   preserveWhitespace: false,
 *   includeComments: false
 * };
 * const soup = new Soup("<div>Hello</div>", config);
 * ```
 */
export interface SoupConfig {
  /** Maximum nesting depth for DOM tree. Default: 512 */
  maxDepth?: number
  /** Enable strict parsing mode. Default: false */
  strictMode?: boolean
  /** Preserve whitespace-only text nodes. Default: false */
  preserveWhitespace?: boolean
  /** Include comment nodes in DOM. Default: false */
  includeComments?: boolean
}

/** Get the library version. */
export declare function version(): string
